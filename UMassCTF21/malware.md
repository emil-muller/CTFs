# Malware

First we check out the `malware.py` file.

```
➜  malware cat malware.py
from Crypto.Cipher import AES
from Crypto.Util import Counter
import binascii
import os

key = os.urandom(16)
iv = int(binascii.hexlify(os.urandom(16)), 16)

for file_name in os.listdir():
    data = open(file_name, 'rb').read()

    cipher = AES.new(key, AES.MODE_CTR, counter = Counter.new(128, initial_value=iv))

    enc = open(file_name + '.enc', 'wb')
    enc.write(cipher.encrypt(data))

    iv += 1
```
We notice here that the key is reused and that the `iv` is only incremented by 1 for every file.

If we unzip the files we get:
```
 ➜  malware unzip files.zip
Archive:  files.zip
  inflating: CTF-favicon.png.enc     
  inflating: flag.txt.enc            
  inflating: malware.py.enc          
  inflating: shopping_list.txt.enc
```
We notice that `malware.py.enc` is a part of the encrypted files. Now we have a known plaintext/ciphertext pair!
This is good (for us)! This allows us to calculate all the encrypted counter/key pairs by XOR'ing the plain text and the ciphertext!

![AES CTR mode](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/CTR_encryption_2.svg/1920px-CTR_encryption_2.svg.png)

Since the `iv` is only incremented by 1 for every file, we can decrypt `flag.txt` if it was encrypted after `malware.py`. This is due to the fact that since the key is reused, some block in `malware.py.enc` will have the same encrypted counter/key pair as some block in `flag.txt.enc`. Once we know an encrypted counter/key pair and a block of ciphertext, we can simply XOR them and get the plaintext.

Mathematically we ca see this as:
```
c_i = E_k(i,IV) ⊕ m_i
<=>
m_i = c_i ⊕ E_k(i,IV)
```
With out loss of generality, let's say that `malware.py` is encrypted with `IV=0x0`, then the second block will have `E_k(0x0+0x1)=E_k(0x1)`. If `flag.txt` is encrypted with `IV=0x1` then the first block will have `E_k(0x1+0x0)=E_k(0x1)`. Now since we have the ciphertext of `flag.txt.enc` and we're able to calculate some `E_k(i,IV)` from `malware.py`. We can decrypt `flag.txt.enc` by calculating `m_i = c_i ⊕ E_k(i,IV)`

So without further ado, here my shitty code that solves this challenge:
```
# Calculate As many E_k(i,IV) as possible
with open("files/malware.py.enc", "rb") as f:
    encrypted = f.read()
    unencrypted = open("malware.py", 'rb').read()
    e_ks = []
    for i in range(25):
        e_k = bytearray([])
        for j in range(16):
            e_k.append(encrypted[i*16+j]^unencrypted[i*16+j])
        e_ks.append(e_k)

# Decrypt flag using calculated E_k(i,IV)
with open("files/flag.txt.enc", "rb") as f:
    flag = f.read()
    decrypted_flag = ""
    for j in range(int(len(flag)/16)+1):
        try:
            for i in range(16):
                # Offset 2 in e_ks[2+j] has been chosen from trial and error
                decrypted_flag += chr(e_ks[2+j][i]^flag[i+16*j])
        except:
            print(decrypted_flag)
```
```
➜  malware python decrypter.py
UMASS{m4lw4re_st1ll_n33ds_g00d_c4ypt0}
```
